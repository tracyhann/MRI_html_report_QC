<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Local MRI Report(.html) QC</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111826;
      --panel2:#0f1722;
      --text:#e6edf3;
      --muted:#9fb0c0;
      --border:#243246;
      --accent:#5aa9ff;
      --good:#2dd4bf;
      --warn:#fbbf24;
      --bad:#fb7185;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius:14px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:linear-gradient(180deg, #070a0f, #0b0f14 40%, #0b0f14);
      color:var(--text);
      font-family:var(--sans);
      font-size:16px; /* <-- added */
      height:100vh;
      overflow:hidden;
    }

    header{
      height:60px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 14px;
      border-bottom:1px solid var(--border);
      background:rgba(15,23,34,.85);
      backdrop-filter: blur(8px);
    }
    header .left, header .right{
      display:flex; gap:10px; align-items:center;
    }
    .btn{
      border:1px solid var(--border);
      font-size:14px;
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      transition:.12s transform, .12s border-color;
      user-select:none;
    }
    .btn:hover{ transform: translateY(-1px); border-color:#3a4d6a; }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ border-color: rgba(90,169,255,.55); }
    .btn.danger{ border-color: rgba(251,113,133,.55); }
    .btn.ghost{ background:transparent; }
    .pill{
      font-family:var(--mono);
      font-size:14px;
      color:var(--muted);
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.03);
    }
    .layout{
      display:grid;
      grid-template-columns: 360px 1fr;
      height: calc(100vh - 60px);
    }
    aside{
      border-right:1px solid var(--border);
      background:rgba(17,24,38,.85);
      backdrop-filter: blur(8px);
      display:flex;
      flex-direction:column;
      min-width: 320px;
    }
    .aside-top{
      padding:12px;
      border-bottom:1px solid var(--border);
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{ display:flex; gap:8px; align-items:center; }
    input[type="text"]{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      color:var(--text);
      outline:none;
      font-size:16px;
    }
    input[type="text"]::placeholder{ color:rgba(159,176,192,.65); }
    .list{
      overflow:auto;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .item{
      border:1px solid var(--border);
      background:rgba(255,255,255,.02);
      border-radius:12px;
      padding:10px 10px;
      cursor:pointer;
      display:flex;
      gap:10px;
      align-items:flex-start;
      transition:.12s border-color, .12s transform, .12s background;
    }
    .item:hover{ border-color:#3a4d6a; transform: translateY(-1px); }
    .item.active{
      border-color: rgba(90,169,255,.7);
      background: rgba(90,169,255,.08);
    }
    .item .meta{ flex:1; min-width:0; }
    .item .name{
      font-weight:700; font-size:14px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .item .path{
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      margin-top:4px;
    }
    .badge{
      font-family:var(--mono);
      font-weight:800;
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      color:var(--muted);
      margin-top:2px;
      flex-shrink:0;
    }
    .badge.good{ border-color: rgba(45,212,191,.55); color: var(--good); }
    .badge.warn{ border-color: rgba(251,191,36,.55); color: var(--warn); }
    .badge.bad{  border-color: rgba(251,113,133,.55); color: var(--bad); }
    main{
      background: radial-gradient(1200px 600px at 30% -10%, rgba(90,169,255,.10), transparent 60%),
                  radial-gradient(900px 500px at 90% 10%, rgba(45,212,191,.10), transparent 55%),
                  rgba(11,15,20,.9);
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .main-top{
      padding:12px 14px;
      border-bottom:1px solid var(--border);
      background:rgba(15,23,34,.75);
      backdrop-filter: blur(8px);
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
    }
    .controls{
      display:flex; flex-wrap:wrap; gap:8px; align-items:center;
    }
    .tagbar{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .tagbtn{
      border:1px solid var(--border);
      border-radius:999px;
      padding:8px 12px;
      cursor:pointer;
      font-weight:800;
      user-select:none;
      background:rgba(255,255,255,.03);
      transition:.12s transform, .12s border-color, .12s background;
    }
    .tagbtn:hover{ transform: translateY(-1px); }
    .tagbtn.good{ border-color: rgba(45,212,191,.55); }
    .tagbtn.warn{ border-color: rgba(251,191,36,.55); }
    .tagbtn.bad{ border-color: rgba(251,113,133,.55); }
    .tagbtn.active.good{ background: rgba(45,212,191,.12); }
    .tagbtn.active.warn{ background: rgba(251,191,36,.12); }
    .tagbtn.active.bad{  background: rgba(251,113,133,.12); }
    .notes{
      width: 420px;
      max-width: 50vw;
      min-height: 40px;
      height: 40px;
      resize: vertical;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      color:var(--text);
      padding:10px 12px;
      outline:none;
      font-size:13px;
    }
    .viewer{
      flex:1;
      overflow:hidden;
      padding:12px;
    }
    .grid{
      height:100%;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .grid.two{ grid-template-columns: 1fr 1fr; }
    .grid.three{ grid-template-columns: 1fr 1fr 1fr; }
    .framewrap{
      height:100%;
      border:1px solid var(--border);
      border-radius: var(--radius);
      overflow:hidden;
      background: rgba(17,24,38,.6);
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      min-width: 0;
    }
    .frametop{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background: rgba(255,255,255,.02);
    }
    .frametop .title{
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex:1;
      min-width:0;
    }
    iframe{
      width:100%;
      height:100%;
      border:0;
      background:#fff;
    }
    .hint{
      font-size:12px;
      color:rgba(159,176,192,.85);
      line-height:1.35;
    }
    .kbd{
      font-family:var(--mono);
      border:1px solid var(--border);
      border-bottom-color:#182233;
      background:rgba(255,255,255,.03);
      padding:2px 6px;
      border-radius:6px;
      margin:0 3px;
      font-size:11px;
    }
    .modal-backdrop{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.55);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:9999;
  }
  .modal{
    width:min(1100px, 92vw);
    height:min(720px, 85vh);
    border:1px solid var(--border);
    border-radius:16px;
    background:rgba(17,24,38,.96);
    box-shadow: var(--shadow);
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .modal-header{
    padding:12px 14px;
    border-bottom:1px solid var(--border);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    background:rgba(255,255,255,.02);
  }
  .modal-title{
    font-weight:900;
    letter-spacing:.2px;
  }
  .modal-body{
    padding:12px;
    overflow:auto;
  }
  .table{
    width:100%;
    border-collapse:separate;
    border-spacing:0;
    font-size:14px;
  }
  .table th, .table td{
    border-bottom:1px solid rgba(36,50,70,.65);
    padding:10px 10px;
    text-align:left;
    vertical-align:top;
  }
  .table th{
    position:sticky;
    top:0;
    background:rgba(17,24,38,.98);
    z-index:1;
    font-weight:900;
  }
  .table td{
    color:rgba(230,237,243,.95);
  }
  .truncate{
    max-width:520px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }
  .modal-controls{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }
  select{
    border:1px solid var(--border);
    background:rgba(255,255,255,.03);
    color:var(--text);
    padding:8px 10px;
    border-radius:10px;
    outline:none;
    font-weight:700;
  }
  .small-note{
    font-size:12px;
    color:rgba(159,176,192,.9);
  }

  </style>
</head>

<body>
<header>
  <div class="left">
    <div class="pill">Local MRI Report(.html) QC</div>
    <div class="pill" id="statusPill">No folder loaded</div>
  </div>
  <div class="right">
    <button class="btn primary" id="pickFolderBtn">Pick Folder</button>
    <button class="btn" id="previewCsvBtn">Preview CSV</button>
    <button class="btn" id="downloadCsvBtn">Download CSV</button>
    <button class="btn" id="downloadBackupBtn">Backup JSON</button>
    <button class="btn ghost danger" id="clearBtn" title="Clears saved decisions (localStorage) and current session">Clear</button>
  </div>
</header>

<div class="layout">
  <aside>
    <div class="aside-top">
      <input id="searchBox" type="text" placeholder="Search… (subject/session/run/report.html)" />
      <div class="row" style="justify-content:space-between;">
        <div class="hint">
          Keys:
          <span class="kbd">↑</span><span class="kbd">↓</span> navigate
          <span class="kbd">Enter</span> open
          <span class="kbd">1</span> accept
          <span class="kbd">2</span> uncertain
          <span class="kbd">3</span> reject
          <span class="kbd">Shift</span>+<span class="kbd">Enter</span> add compare
          <span class="kbd">Esc</span> clear compare
        </div>
      </div>
    </div>
    <div class="list" id="fileList"></div>
  </aside>

  <main>
    <div class="main-top">
      <div class="controls">
        <div class="pill" id="currentFilePill">No file selected</div>
        <div class="pill" id="comparePill">Compare: 0</div>
        <button class="btn" id="prevBtn">Prev</button>
        <button class="btn" id="nextBtn">Next</button>
        <button class="btn" id="openSoloBtn" title="Open selected report as the only pane">Open Solo</button>
        <button class="btn" id="addCompareBtn" title="Add selected report as a comparison pane">Add Compare</button>
        <button class="btn" id="removeCompareBtn" title="Remove last comparison pane">Remove Compare</button>
      </div>

      <div class="tagbar">
        <div class="tagbtn good" id="tagAccept">Accept (1)</div>
        <div class="tagbtn warn" id="tagUncertain">Uncertain (2)</div>
        <div class="tagbtn bad" id="tagReject">Reject (3)</div>
        <textarea class="notes" id="notesBox" placeholder="Notes… (autosaves for this file)"></textarea>
      </div>
    </div>

    <div class="viewer">
      <div class="grid" id="grid"></div>
    </div>
  </main>
</div>

<input type="file" id="fallbackDirInput" webkitdirectory multiple hidden />

<div class="modal-backdrop" id="csvModal">
  <div class="modal" role="dialog" aria-modal="true" aria-label="CSV Preview">
    <div class="modal-header">
      <div class="modal-controls">
        <div class="modal-title">CSV Preview</div>
        <div class="pill" id="csvPreviewCount">0 rows</div>

        <select id="csvFilterTag">
          <option value="">All tags</option>
          <option value="accept">Accept</option>
          <option value="uncertain">Uncertain</option>
          <option value="reject">Reject</option>
          <option value="unset">Unset</option>
        </select>

        <input id="csvSearch" type="text" placeholder="Search relPath / notes…" style="width:320px;max-width:60vw;" />
        <div class="small-note">Tip: click a row to jump to that report.</div>
      </div>

      <div class="modal-controls">
        <button class="btn" id="csvRefreshBtn">Refresh</button>
        <button class="btn" id="csvCloseBtn">Close</button>
      </div>
    </div>

    <div class="modal-body">
      <table class="table">
        <thead>
          <tr>
            <th style="width:170px;">timestamp</th>
            <th>relPath</th>
            <th style="width:110px;">tag</th>
            <th>notes</th>
          </tr>
        </thead>
        <tbody id="csvTbody"></tbody>
      </table>
    </div>
  </div>
</div>


<script>
(() => {
  // -----------------------------
  // State + persistence
  // -----------------------------
  const LS_KEY = "local_html_qc__decisions_v1";
  const LS_BACKUP_KEY = "local_html_qc__backup_v1";

  /** @type {{[relPath: string]: {tag: string, notes: string, updatedAt: string}}} */
  let decisions = {};
  /** @type {{ relPath: string, file: File, url?: string, type: 'html'|'asset' }[]} */
  let entries = [];
  /** @type {{ relPath: string, file: File }[]} */
  let htmlEntries = [];
  /** @type {Map<string, string>} pathToObjectUrl */
  let pathToObjectUrl = new Map();

  let filtered = [];
  let activeIndex = -1;

  /** compare panes: array of relPaths */
  let panes = [];

  // -----------------------------
  // Elements
  // -----------------------------
  const previewCsvBtn = document.getElementById("previewCsvBtn");
  const csvModal = document.getElementById("csvModal");
  const csvCloseBtn = document.getElementById("csvCloseBtn");
  const csvRefreshBtn = document.getElementById("csvRefreshBtn");
  const csvTbody = document.getElementById("csvTbody");
  const csvPreviewCount = document.getElementById("csvPreviewCount");
  const csvSearch = document.getElementById("csvSearch");
  const csvFilterTag = document.getElementById("csvFilterTag");

  const statusPill = document.getElementById("statusPill");
  const fileList = document.getElementById("fileList");
  const searchBox = document.getElementById("searchBox");
  const currentFilePill = document.getElementById("currentFilePill");
  const comparePill = document.getElementById("comparePill");
  const grid = document.getElementById("grid");

  const pickFolderBtn = document.getElementById("pickFolderBtn");
  const fallbackDirInput = document.getElementById("fallbackDirInput");

  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const openSoloBtn = document.getElementById("openSoloBtn");
  const addCompareBtn = document.getElementById("addCompareBtn");
  const removeCompareBtn = document.getElementById("removeCompareBtn");

  const tagAccept = document.getElementById("tagAccept");
  const tagUncertain = document.getElementById("tagUncertain");
  const tagReject = document.getElementById("tagReject");
  const notesBox = document.getElementById("notesBox");

  const downloadCsvBtn = document.getElementById("downloadCsvBtn");
  const downloadBackupBtn = document.getElementById("downloadBackupBtn");
  const clearBtn = document.getElementById("clearBtn");

  // -----------------------------
  // Helpers
  // -----------------------------
  const nowIso = () => new Date().toISOString();

  function loadDecisions() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (raw) decisions = JSON.parse(raw) || {};
    } catch (e) {
      decisions = {};
    }
  }

  function saveDecisions() {
    localStorage.setItem(LS_KEY, JSON.stringify(decisions));
    localStorage.setItem(LS_BACKUP_KEY, JSON.stringify({ savedAt: nowIso(), decisions }));
  }

  function clearAll() {
    decisions = {};
    saveDecisions();
    renderList();
    renderActiveMeta();
  }

  function safeRelPath(file) {
    // For webkitdirectory uploads, browsers set webkitRelativePath.
    // For File System Access API, we set relPath manually.
    return file.webkitRelativePath || file.name;
  }

  function tagLabel(tag) {
    if (tag === "accept") return "ACCEPT";
    if (tag === "uncertain") return "UNCERTAIN";
    if (tag === "reject") return "REJECT";
    return "UNSET";
  }

  function tagClass(tag) {
    if (tag === "accept") return "good";
    if (tag === "uncertain") return "warn";
    if (tag === "reject") return "bad";
    return "";
  }

  function setStatus(text) {
    statusPill.textContent = text;
  }

  function escapeCsv(s) {
    const v = (s ?? "").toString();
    if (/[",\n]/.test(v)) return `"${v.replace(/"/g, '""')}"`;
    return v;
  }

  function computeDisplayName(relPath) {
    // show last 2 segments
    const parts = relPath.split("/").filter(Boolean);
    if (parts.length <= 2) return relPath;
    return parts.slice(-2).join("/");
  }

  function deriveQuickMeta(relPath) {
    // crude extractor: sub-XXXX / ses-XXXX / run-XX etc from path
    const parts = relPath.split("/");
    const hit = (re) => {
      for (const p of parts) { const m = p.match(re); if (m) return m[0]; }
      return "";
    };
    return {
      sub: hit(/^sub-[^/]+$/),
      ses: hit(/^ses-[^/]+$/),
      task: hit(/^task-[^/]+$/),
      run: hit(/^run-[^/]+$/)
    };
  }

  function buildObjectUrlIndex(allEntries) {
    // Revoke old URLs
    for (const url of pathToObjectUrl.values()) URL.revokeObjectURL(url);
    pathToObjectUrl.clear();

    for (const e of allEntries) {
      const url = URL.createObjectURL(e.file);
      pathToObjectUrl.set(e.relPath, url);
      e.url = url;
    }
  }

  function isHtmlPath(p) {
    return p.toLowerCase().endsWith(".html") || p.toLowerCase().endsWith(".htm");
  }

  function normalizeRelPath(p) {
    return p.replace(/\\/g, "/").replace(/^\/+/, "");
  }

  function isFirstLevelHtml(relPath) {
    // first level = no "/" in path
    // and must be .html/.htm
    return isHtmlPath(relPath) && !relPath.includes("/");
  }


  function resolveRelativePath(baseRelPath, rel) {
    // baseRelPath includes filename; resolve rel against its directory
    const baseDir = baseRelPath.split("/").slice(0, -1).join("/");
    const joined = (baseDir ? baseDir + "/" : "") + rel;
    const parts = joined.split("/").filter(Boolean);
    const out = [];
    for (const part of parts) {
      if (part === ".") continue;
      if (part === "..") out.pop();
      else out.push(part);
    }
    return out.join("/");
  }

  function shouldRewriteUrl(u) {
    if (!u) return false;
    const s = u.trim();
    if (s.startsWith("#")) return false;
    if (s.startsWith("data:")) return false;
    if (s.startsWith("blob:")) return false;
    if (s.startsWith("http:") || s.startsWith("https:")) return false;
    if (s.startsWith("mailto:") || s.startsWith("tel:")) return false;
    return true;
  }

  async function buildSrcdocForHtml(relPath) {
    // Reads the HTML file and rewrites relative asset links to blob URLs if available.
    const entry = htmlEntries.find(e => e.relPath === relPath);
    if (!entry) return "<h1>Missing file</h1>";

    const text = await entry.file.text();

    // Parse HTML to rewrite src/href for common tags
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, "text/html");

    // rewrite <img src>, <script src>, <link href>, <iframe src>, <source src>, <video poster>, etc.
    const rewriteAttr = (selector, attr) => {
      doc.querySelectorAll(selector).forEach(el => {
        const val = el.getAttribute(attr);
        if (!shouldRewriteUrl(val)) return;
        const resolved = normalizeRelPath(resolveRelativePath(relPath, val));
        const blobUrl = pathToObjectUrl.get(resolved);
        if (blobUrl) el.setAttribute(attr, blobUrl);
      });
    };

    rewriteAttr("img[src]", "src");
    rewriteAttr("script[src]", "src");
    rewriteAttr("link[href]", "href");
    rewriteAttr("iframe[src]", "src");
    rewriteAttr("source[src]", "src");
    rewriteAttr("video[poster]", "poster");
    rewriteAttr("a[href]", "href"); // keeps navigation inside blob if referenced file exists

    // Some reports use <object data="...">
    rewriteAttr("object[data]", "data");
    // Some use <embed src="...">
    rewriteAttr("embed[src]", "src");

    // Note: CSS url(...) inside stylesheets is not rewritten here.
    // For fMRIPrep reports, this is usually fine because the report is mostly self-contained.

    return "<!doctype html>\n" + doc.documentElement.outerHTML;
  }

  function updateGridClass() {
    grid.classList.remove("two", "three");
    if (panes.length === 2) grid.classList.add("two");
    if (panes.length >= 3) grid.classList.add("three");
  }

  async function renderPanes() {
    grid.innerHTML = "";
    updateGridClass();

    if (panes.length === 0) {
      grid.innerHTML = `
        <div class="framewrap" style="align-items:center;justify-content:center;padding:18px;">
          <div style="max-width:720px;">
            <div style="font-size:20px;font-weight:900;margin-bottom:10px;">Load a folder of reports, then start tagging.</div>
            <div class="hint" style="font-size:13px;">
              This app reads your HTML reports locally and renders them in iframes using <span class="kbd">srcdoc</span>
              so you can QC without spinning up a server.
              <br/><br/>
              Pick a folder that contains your fMRIPrep report <span class="kbd">.html</span> files (and their assets).
              Use <span class="kbd">Shift</span>+<span class="kbd">Enter</span> to add comparisons.
            </div>
          </div>
        </div>`;
      return;
    }

    for (let i = 0; i < panes.length; i++) {
      const relPath = panes[i];
      const meta = deriveQuickMeta(relPath);
      const dec = decisions[relPath] || { tag:"", notes:"" };
      const topTag = dec.tag ? tagLabel(dec.tag) : "UNSET";

      const wrap = document.createElement("div");
      wrap.className = "framewrap";

      const top = document.createElement("div");
      top.className = "frametop";

      const title = document.createElement("div");
      title.className = "title";
      title.textContent = `${relPath}   ${[meta.sub, meta.ses, meta.task, meta.run].filter(Boolean).join("  ")}`;

      const b = document.createElement("div");
      b.className = "badge " + tagClass(dec.tag);
      b.textContent = topTag;

      top.appendChild(title);
      top.appendChild(b);

      const iframe = document.createElement("iframe");
      iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-forms allow-popups");
      // Build srcdoc
      iframe.srcdoc = await buildSrcdocForHtml(relPath);

      wrap.appendChild(top);
      wrap.appendChild(iframe);
      grid.appendChild(wrap);
    }
  }

  function setActiveByRelPath(relPath) {
    const idx = filtered.findIndex(e => e.relPath === relPath);
    if (idx >= 0) activeIndex = idx;
    renderList();
    renderActiveMeta();
  }

  function getActiveRelPath() {
    if (activeIndex < 0 || activeIndex >= filtered.length) return null;
    return filtered[activeIndex].relPath;
  }

  function renderActiveMeta() {
    const rp = getActiveRelPath();
    currentFilePill.textContent = rp ? rp : "No file selected";
    comparePill.textContent = `Compare: ${panes.length}`;
    // sync tag UI + notes box
    const d = rp ? (decisions[rp] || {}) : {};
    setTagUi(d.tag || "");
    notesBox.value = d.notes || "";
  }

  function setTagUi(tag) {
    for (const el of [tagAccept, tagUncertain, tagReject]) el.classList.remove("active");
    if (tag === "accept") tagAccept.classList.add("active");
    if (tag === "uncertain") tagUncertain.classList.add("active");
    if (tag === "reject") tagReject.classList.add("active");
  }

  function setDecision(relPath, tag, notes=null) {
    if (!relPath) return;
    const prev = decisions[relPath] || {};
    decisions[relPath] = {
      tag,
      notes: notes !== null ? notes : (prev.notes || ""),
      updatedAt: nowIso()
    };
    saveDecisions();
    renderList();
    renderActiveMeta();
    // Update pane headers quickly by rerendering panes (cheap enough)
    renderPanes();
  }

  function updateNotes(relPath, notes) {
    if (!relPath) return;
    const prev = decisions[relPath] || { tag:"", notes:"" };
    decisions[relPath] = { ...prev, notes, updatedAt: nowIso() };
    saveDecisions();
    // Don't spam rerenders while typing in list; but keep pill sync
  }

  function applyFilter() {
    const q = searchBox.value.trim().toLowerCase();
    filtered = htmlEntries.filter(e => {
      const rp = e.relPath.toLowerCase();
      if (!q) return true;
      return rp.includes(q);
    });
    if (filtered.length === 0) activeIndex = -1;
    else if (activeIndex < 0 || activeIndex >= filtered.length) activeIndex = 0;
  }

  function renderList() {
    applyFilter();
    fileList.innerHTML = "";

    const frag = document.createDocumentFragment();
    filtered.forEach((e, idx) => {
      const dec = decisions[e.relPath] || {};
      const item = document.createElement("div");
      item.className = "item" + (idx === activeIndex ? " active" : "");
      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = computeDisplayName(e.relPath);

      const path = document.createElement("div");
      path.className = "path";
      path.textContent = e.relPath;

      meta.appendChild(name);
      meta.appendChild(path);

      const badge = document.createElement("div");
      badge.className = "badge " + tagClass(dec.tag);
      badge.textContent = dec.tag ? tagLabel(dec.tag) : "UNSET";

      item.appendChild(meta);
      item.appendChild(badge);

      item.addEventListener("click", () => {
        activeIndex = idx;
        renderList();
        renderActiveMeta();
      });
      item.addEventListener("dblclick", async () => {
        activeIndex = idx;
        openSolo();
      });

      frag.appendChild(item);
    });

    fileList.appendChild(frag);

    // status
    if (htmlEntries.length) {
      const tagged = Object.keys(decisions).length;
      setStatus(`${htmlEntries.length} reports • ${tagged} tagged`);
    } else {
      setStatus("No folder loaded");
    }
  }

  function clampActive() {
    if (filtered.length === 0) { activeIndex = -1; return; }
    activeIndex = Math.max(0, Math.min(activeIndex, filtered.length - 1));
  }

  function nextItem() {
    if (filtered.length === 0) return;
    activeIndex++;
    clampActive();
    renderList();
    renderActiveMeta();
  }

  function prevItem() {
    if (filtered.length === 0) return;
    activeIndex--;
    clampActive();
    renderList();
    renderActiveMeta();
  }

  async function openSolo() {
    const rp = getActiveRelPath();
    if (!rp) return;
    panes = [rp];
    renderActiveMeta();
    await renderPanes();
  }

  async function addCompare() {
    const rp = getActiveRelPath();
    if (!rp) return;
    if (panes.includes(rp)) return;
    if (panes.length >= 3) panes.shift(); // keep at most 3
    panes.push(rp);
    renderActiveMeta();
    await renderPanes();
  }

  async function removeCompare() {
    panes.pop();
    renderActiveMeta();
    await renderPanes();
  }

  async function clearCompare() {
    panes = [];
    renderActiveMeta();
    await renderPanes();
  }

  // -----------------------------
  // Folder loading
  // -----------------------------
  async function pickFolder() {
    // Prefer File System Access API (Chrome/Edge). Fallback: <input webkitdirectory>.
    if ("showDirectoryPicker" in window) {
      const handle = await window.showDirectoryPicker();
      await loadFromDirectoryHandle(handle);
    } else {
      fallbackDirInput.click();
    }
  }

  async function loadFromDirectoryHandle(dirHandle) {
    entries = [];
    htmlEntries = [];

    async function walk(handle, prefix="") {
      for await (const [name, child] of handle.entries()) {
        const rel = prefix ? `${prefix}/${name}` : name;
        if (child.kind === "directory") {
          await walk(child, rel);
        } else if (child.kind === "file") {
          const file = await child.getFile();
          const relPath = normalizeRelPath(rel);
          entries.push({ relPath, file, type: isHtmlPath(relPath) ? "html" : "asset" });
        }
      }
    }

    await walk(dirHandle);
    finalizeLoad();
  }

  function loadFromFileList(fileListObj) {
    entries = [];
    htmlEntries = [];
    for (const file of fileListObj) {
      const relPath = normalizeRelPath(safeRelPath(file));
      entries.push({ relPath, file, type: isHtmlPath(relPath) ? "html" : "asset" });
    }
    finalizeLoad();
  }

  function finalizeLoad() {
    // Keep only html reports (you can change this to only fmriprep-like names if you want)
    // List ONLY first-level HTML files, but keep all files in `entries` for assets rewriting.
    htmlEntries = entries.filter(e => e.type === "html" && isFirstLevelHtml(e.relPath));
    // Build blob URL index for ALL files (so assets can be rewritten)
    buildObjectUrlIndex(entries);

    // Load saved decisions
    loadDecisions();

    // If decisions contain files not in this folder, keep them (so you can reuse across loads),
    // but list rendering will only show current folder files.
    filtered = [...htmlEntries];
    activeIndex = filtered.length ? 0 : -1;
    panes = [];

    renderList();
    renderActiveMeta();
    renderPanes();

    // Try to auto-open first file
    if (filtered.length) openSolo();
  }

  // -----------------------------
  // Export
  // -----------------------------
  function openCsvModal() {
    csvModal.style.display = "flex";
    renderCsvPreview();
    csvSearch.focus();
  }

  function closeCsvModal() {
    csvModal.style.display = "none";
  }

  function getCurrentFolderDecisionRows() {
    const currentSet = new Set(htmlEntries.map(e => e.relPath));
    const keys = Object.keys(decisions).sort((a,b)=>a.localeCompare(b));
    const rows = [];

    for (const relPath of keys) {
      if (!currentSet.has(relPath)) continue; // current folder only
      const d = decisions[relPath] || {};
      const tag = d.tag || "";
      const notes = d.notes || "";
      const ts = d.updatedAt || "";
      // include if anything exists OR include unset (for full audit)
      rows.push({ ts, relPath, tag: tag || "unset", notes });
    }

    // Also include untagged files (present in folder but no decision entry)
    for (const e of htmlEntries) {
      if (!decisions[e.relPath]) {
        rows.push({ ts:"", relPath: e.relPath, tag:"unset", notes:"" });
      }
    }

    // de-dup (in case above added overlap)
    const seen = new Set();
    return rows.filter(r => {
      if (seen.has(r.relPath)) return false;
      seen.add(r.relPath);
      return true;
    }).sort((a,b)=>a.relPath.localeCompare(b.relPath));
  }

  function renderCsvPreview() {
    const q = (csvSearch.value || "").trim().toLowerCase();
    const tagFilter = csvFilterTag.value; // accept/uncertain/reject/unset/""(all)

    let rows = getCurrentFolderDecisionRows();

    if (tagFilter) {
      rows = rows.filter(r => (r.tag || "unset") === tagFilter);
    }

    if (q) {
      rows = rows.filter(r =>
        r.relPath.toLowerCase().includes(q) ||
        (r.notes || "").toLowerCase().includes(q) ||
        (r.tag || "").toLowerCase().includes(q)
      );
    }

    csvPreviewCount.textContent = `${rows.length} rows`;
    csvTbody.innerHTML = "";

    const frag = document.createDocumentFragment();
    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.style.cursor = "pointer";

      tr.innerHTML = `
        <td>${(r.ts || "")}</td>
        <td class="truncate" title="${r.relPath.replace(/"/g,"&quot;")}">${r.relPath}</td>
        <td><span class="badge ${tagClass(r.tag === "unset" ? "" : r.tag)}">${tagLabel(r.tag === "unset" ? "" : r.tag)}</span></td>
        <td class="truncate" title="${(r.notes||"").replace(/"/g,"&quot;")}">${(r.notes || "")}</td>
      `;

      tr.addEventListener("click", async () => {
        // jump to file and open it
        closeCsvModal();
        setActiveByRelPath(r.relPath);
        await openSolo();
      });

      frag.appendChild(tr);
    }
    csvTbody.appendChild(frag);
  }

  function downloadCsv() {
    // CSV columns: timestamp, relPath, filename, tag, notes
    const rows = [];
    rows.push(["timestamp","relPath","filename","tag","notes"].map(escapeCsv).join(","));

    // Include decisions for files in current folder first, then other decisions
    const currentSet = new Set(htmlEntries.map(e => e.relPath));
    const keys = Object.keys(decisions).sort((a,b)=>a.localeCompare(b));
    for (const relPath of keys) {
      const d = decisions[relPath];
      const filename = relPath.split("/").pop();
      const ts = d.updatedAt || "";
      const tag = d.tag || "";
      const notes = d.notes || "";
      // only export ones with at least a tag or note
      if (!tag && !notes) continue;
      // optional: export only current folder. comment out if you want global.
      if (!currentSet.has(relPath)) continue;

      rows.push([ts, relPath, filename, tag, notes].map(escapeCsv).join(","));
    }

    const blob = new Blob([rows.join("\n")], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `qc_decisions_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadBackupJson() {
    const payload = {
      savedAt: nowIso(),
      decisions,
      // lightweight context (current folder files)
      currentFolderFiles: htmlEntries.map(e => e.relPath)
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `qc_backup_${new Date().toISOString().slice(0,19).replace(/[:T]/g,"-")}.json`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // -----------------------------
  // Wiring
  // -----------------------------
  pickFolderBtn.addEventListener("click", async () => {
    try { await pickFolder(); }
    catch (e) { console.error(e); }
  });

  fallbackDirInput.addEventListener("change", (ev) => {
    if (ev.target.files && ev.target.files.length) loadFromFileList(ev.target.files);
  });

  searchBox.addEventListener("input", () => {
    renderList();
    renderActiveMeta();
  });

  prevBtn.addEventListener("click", prevItem);
  nextBtn.addEventListener("click", nextItem);

  openSoloBtn.addEventListener("click", openSolo);
  addCompareBtn.addEventListener("click", addCompare);
  removeCompareBtn.addEventListener("click", removeCompare);

  tagAccept.addEventListener("click", () => setDecision(getActiveRelPath(), "accept"));
  tagUncertain.addEventListener("click", () => setDecision(getActiveRelPath(), "uncertain"));
  tagReject.addEventListener("click", () => setDecision(getActiveRelPath(), "reject"));

  previewCsvBtn.addEventListener("click", openCsvModal);
  csvCloseBtn.addEventListener("click", closeCsvModal);
  csvRefreshBtn.addEventListener("click", renderCsvPreview);

  csvSearch.addEventListener("input", renderCsvPreview);
  csvFilterTag.addEventListener("change", renderCsvPreview);

  // click outside modal closes it
  csvModal.addEventListener("click", (e) => {
    if (e.target === csvModal) closeCsvModal();
  });

  notesBox.addEventListener("input", () => {
    updateNotes(getActiveRelPath(), notesBox.value);
  });
  notesBox.addEventListener("blur", () => {
    // On blur, sync rerenders (optional)
    saveDecisions();
    renderList();
    renderPanes();
  });

  downloadCsvBtn.addEventListener("click", downloadCsv);
  downloadBackupBtn.addEventListener("click", downloadBackupJson);

  clearBtn.addEventListener("click", async () => {
    if (!confirm("Clear saved decisions for this app (localStorage)?")) return;
    clearAll();
    await renderPanes();
  });

  // Keyboard shortcuts
  window.addEventListener("keydown", async (e) => {
    // If typing in search or notes, allow usual typing, but keep tag keys.
    const tagKeys = ["1","2","3"];
    const inText = (document.activeElement === searchBox || document.activeElement === notesBox);

    if (e.key === "ArrowDown") { e.preventDefault(); nextItem(); return; }
    if (e.key === "ArrowUp") { e.preventDefault(); prevItem(); return; }
    if (e.key === "Escape" && csvModal.style.display === "flex") {
      e.preventDefault();
      closeCsvModal();
      return;
    }


    if (e.key === "Enter") {
      e.preventDefault();
      if (e.shiftKey) await addCompare();
      else await openSolo();
      return;
    }

    if (e.key === "Escape") { e.preventDefault(); await clearCompare(); return; }

    if (tagKeys.includes(e.key)) {
      e.preventDefault();
      const rp = getActiveRelPath();
      if (!rp) return;
      if (e.key === "1") setDecision(rp, "accept");
      if (e.key === "2") setDecision(rp, "uncertain");
      if (e.key === "3") setDecision(rp, "reject");
      return;
    }

    // Don't hijack other keys while typing
    if (inText) return;

    // quick nav by j/k
    if (e.key === "j") { nextItem(); return; }
    if (e.key === "k") { prevItem(); return; }
  });

  // Init
  loadDecisions();
  renderList();
  renderActiveMeta();
  renderPanes();
})();
</script>

</body>
</html>

